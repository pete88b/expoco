# AUTOGENERATED! DO NOT EDIT! File to edit: 05b_ml_model.ipynb (unless otherwise specified).

__all__ = ['save_state_dict', 'load_state_dict', 'get_class_count', 'create_confusion_matrix', 'plot_confusion_matrix',
           'get_idxs_of_interest']

# Cell
from ..core import *
from pathlib import Path
import numpy as np

# Cell
def save_state_dict(path, state_dict, **training_info):
    "Saves `state_dict` and `training_info` to a new model directory"
    model_id = now()
    output_path = path/f'model_{model_id}'
    output_path.mkdir()
    log = LogFile(output_path/'model.log')
    log('output_path:', output_path.resolve())
    log('training_info:', training_info)
    file_name = output_path/'state_dict.npz'
    log('file_name:', file_name)
    np.savez(file_name, **{k:state_dict[k].detach().cpu().numpy() for k in state_dict})
    np.load(file_name) # check that we didn't need to pickle

# Cell
def load_state_dict(path):
    "Load `state_dict.npz` from `path` (a model directory)"
    return np.load(Path(path)/'state_dict.npz')

# Cell
def get_class_count(model):
    return model.modules[-1].weight.shape[1]

# Cell
def create_confusion_matrix(model, df, cont_names, y_name):
    class_count = get_class_count(model)
    confusion_matrix = np.zeros([class_count,class_count], dtype=int)
    output = model(df[cont_names].to_numpy())
    preds = np.argmax(output, axis=1)
    targets = df[y_name].to_numpy()
    for p,t in zip(preds, targets):
        confusion_matrix[t][p]+=1
    return confusion_matrix

# Cell
def plot_confusion_matrix(model, df, cont_names, y_name):
    confusion_matrix = create_confusion_matrix(model, df, cont_names, y_name)
    class_count = get_class_count(model) # class_count might not be the same as len(class_ids)
    class_ids, class_labels = VisemeConfig().get_class_ids_and_labels()
    fig, ax = plt.subplots(figsize=(9,9))
    ax.matshow(confusion_matrix, cmap=plt.cm.Blues, alpha=0.8)
    # ax.xaxis.set_ticks_position('bottom') # must be after matshow
    ax.yaxis.set_label_position('right')
    for i in range(confusion_matrix.shape[0]):
        for j in range(confusion_matrix.shape[1]):
            ax.text(x=j, y=i,s=confusion_matrix[i, j], va='center', ha='center', size='xx-large')
    plt.title('Confusion Matrix', fontsize=14)
    plt.xlabel('Predicted', fontsize=12)
    plt.ylabel('Actual', fontsize=12)
    tick_marks = np.arange(class_count)
    plt.xticks(tick_marks, class_labels[:class_count], rotation=90)
    plt.yticks(tick_marks, class_labels[:class_count], rotation=0)
    plt.show()

# Cell
def get_idxs_of_interest(model, df, cont_names, y_name, target_of_interest, pred_of_interest):
    viseme_config = VisemeConfig()
    output = model(df[cont_names].to_numpy())
    preds = np.argmax(output, axis=1)
    targets = df[y_name].to_numpy()
    idxs = []
    print('target_of_interest', viseme_config.get_class_label(target_of_interest),
          'pred_of_interest', viseme_config.get_class_label(pred_of_interest))
    print('overall accuracy', (targets==preds).sum() / len(targets))
    _filter = targets==target_of_interest
    print('accuracy for target_of_interest',(targets[_filter]==preds[_filter]).sum() / _filter.sum())
    for i, (p,t) in enumerate(zip(preds,targets)):
        if t==target_of_interest and p==pred_of_interest:
            idxs.append(i)
    return idxs